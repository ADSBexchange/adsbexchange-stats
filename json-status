#!/bin/bash
#
# send dumpo1090 json to local or remote server for processing
#

REMOTE_URL="https://adsbexchange.com/api/receive/"

# List all paths, IN PREFERRED ORDER, separated by a SPACE
JSON_PATHS=( "/run/readsb" "/run/dump1090-mutability" "/run/dump1090-fa" )

JSON_DIR=""


# Do this a few times, in case we're still booting up (wait a bit between checks)
CHECK_LOOP=0
while [ "x$JSON_DIR" == "x" ]; do
	# Check the paths IN ORDER, preferring the first one we find
	for i in ${!JSON_PATHS[@]}; do
		CHECK=${JSON_PATHS[$i]}

		if [ -d $CHECK ]; then
			JSON_DIR=$CHECK
			break
		fi
	done

	# no directories just bail
	if [ "x$JSON_DIR" == "x" ]; then
		CHECK_LOOP=$(( CHECK_LOOP + 1 ))
		if [ $CHECK_LOOP -gt 4 ]; then
			# Bad news.  Complain and exit.
			echo "Tried multiple times, could not find any of the directories - ABORTING!"
			exit 10
		fi
		echo "No Valid Directories Found.  Waiting a bit before next check..."
		sleep 20
	fi
done

# uuid
UUID_FILE="/boot/adsbx-uuid"

# look for uuid - if invalid or missing genrate one
if [ -s $UUID_FILE ]; then
        UUID=$(cat $UUID_FILE)
        if ! [[ $UUID =~ ^\{?[A-F0-9a-f]{8}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{12}\}?$ ]]; then
                # invalid - remove and regenerate
                rm -f $UUID_FILE
                UUID=$(uuidgen -t)
                echo $UUID > $UUID_FILE
        fi
else
        #not found generate uuid and write
        UUID=$(uuidgen -t)
        echo $UUID > $UUID_FILE
fi

JSON_FILE="${JSON_DIR}/aircraft.json"

STAT_COUNT=0
# Grab the current timestamp of the file.   Try in a loop a few times, in case
while [ $STAT_COUNT -lt 5 ]; do
	JSON_STAT=$(stat --printf="%Y" $JSON_FILE 2> /dev/null)
	RV=$?

	if [ $RV -eq 0 ];
		break;
	fi
	STAT_COUNT=$(( STAT_COUNT + 1 ))
	sleep 5
done

# Bad juju if we still don't have a stat...
if [ "x$JSON_STAT" == "x" ]; then
	echo "Can't seem to stat $JSON_FILE for the first time, bailing out..."
	exit 15
fi

# Set this to a number
NEXT_JSON_READ=1

# How long to wait before uploads, minimum (in seconds)
WAIT_TIME=5

while true; do
	while [ $JSON_STAT -lt $NEXT_JSON_READ ]; do

		sleep 1

		# Grab new stat.  If it fails, wait longer (otherwise assign to the main var)
		# We could theoretically sit here forever (if the JSON is never updated again),
		# but that's actually OK.
		NEW_STAT=$(stat --printf="%Y" $JSON_FILE 2> /dev/null)
		RV=$?
		if [ $RV -ne 0 ]; then
			sleep 10
		else
			JSON_STAT=$NEW_STAT
		fi
	done
	# Update this for the next loop
	NEXT_JSON_READ=$(( JSON_STAT + $WAIT_TIME ))

	# Move the JSON somewhere before operating on it...
	RAND=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c10)
	TMPFILE="/var/run/json-${RAND}"
	NEWFILE="${TMPFILE}-new"

	cp $JSON_FILE $TMPFILE

	echo '{"uuid":"'$UUID'",' > $NEWFILE
	echo '"aircraft":' >> $NEWFILE
	jq '.aircraft' $TMPFILE >> $NEWFILE
	echo '}' >> $NEWFILE
  
	$(cat $NEWFILE | gzip | curl -s -o /dev/null -X POST -H "Content_Encoding: gzip" --data-binary @- $REMOTE_URL) || true

	rm $TMPFILE $NEWFILE

done

