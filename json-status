#!/bin/bash

#
# Upload output data from decoder to remote server
#

REMOTE_URL="https://adsbexchange.com/api/receive/"

# List all paths, IN PREFERRED ORDER, separated by a SPACE
JSON_PATHS=( "/run/readsb" "/run/dump1090-fa" "/run/dump1090-mutability" "/run/dump1090" )

JSON_DIR=""

TEMP_DIR="/var/run/adsbexchange-stats/"

# Let's make sure the UUID tools are installed...
UUIDGEN=$(command -v uuidgen)
RV=$?

if [ $RV -ne 0 ]; then
	echo "Can't find uuidgen in path, trying to force install the tools..."
	apt-get -y install uuid-runtime
	RV=$?
	if [ $RV -ne 0 ]; then
		echo "Failed to install uuid-runtime package - need manual intervention!"
		sleep 60
		exit 10
	fi
fi

# Check for / create the tmp dir
if [ ! -d $TEMP_DIR ]; then
	echo "Working dir [$TEMP_DIR] doesn't exist, creating..."
	MD=$(mkdir -p $TEMP_DIR 2>&1)
	RV=$?
	if [ $RV -ne 0 ]; then
		echo "FATAL: Failed to create working dir [$TEMP_DIR] ($MD)"
		sleep 5
		exit 20
	fi
fi

# Do this a few times, in case we're still booting up (wait a bit between checks)
CHECK_LOOP=0
while [ "x$JSON_DIR" == "x" ]; do
	# Check the paths IN ORDER, preferring the first one we find
	for i in ${!JSON_PATHS[@]}; do
		CHECK=${JSON_PATHS[$i]}

		if [ -d $CHECK ]; then
			JSON_DIR=$CHECK
			break
		fi
	done

	# Couldn't find any of them...
	if [ "x$JSON_DIR" == "x" ]; then
		CHECK_LOOP=$(( CHECK_LOOP + 1 ))

		if [ $CHECK_LOOP -gt 4 ]; then
			# Bad news.  Complain and exit.
			echo "ERROR: Tried multiple times, could not find any of the directories - ABORTING!"
			exit 10
		fi
		echo "No valid data source directory Found.  Tried each of: [${JSON_PATHS[@]}]"
		echo "Waiting a bit before next check..."
		sleep 20
	fi
done

# UUID file
UUID_FILE="/boot/adsbx-uuid"

# Check for a (valid) UUID...
if [ -f $UUID_FILE ]; then
        UUID=$(cat $UUID_FILE)
        if ! [[ $UUID =~ ^\{?[A-F0-9a-f]{8}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{12}\}?$ ]]; then
                # Data in UUID file is invalid.  Regenerate it!
		echo "WARNING: Data in UUID file was invalid.  Regenerating UUID."
                rm -f $UUID_FILE
                UUID=$($UUIDGEN -t)
                echo $UUID > $UUID_FILE
        fi
else
        # not found generate uuid and save it
	echo "WARNING: No UUID file found, generating new UUID..."
        UUID=$($UUIDGEN -t)
        echo $UUID > $UUID_FILE
fi

echo "Using UUID [${UUID}] for stats uploads..."
echo "Using JSON directory [${JSON_DIR}] for source data..."

JSON_FILE="${JSON_DIR}/aircraft.json"

STAT_COUNT=0
# Grab the current timestamp of the file.   Try in a loop a few times, in case
while [ $STAT_COUNT -lt 5 ]; do
	JSON_STAT=$(stat --printf="%Y" $JSON_FILE 2> /dev/null)
	RV=$?

	if [ $RV -eq 0 ]; then
		break
	fi
	STAT_COUNT=$(( STAT_COUNT + 1 ))
	sleep 15
done

# Bad juju if we still don't have a stat...
if [ "x$JSON_STAT" == "x" ]; then
	echo "ERROR: Can't seem to stat $JSON_FILE at startup, bailing out..."
	exit 15
fi

# Complain if this file seems really old
NOW=$(date +%s)
DIFF=$(( NOW - JSON_STAT ))
if [ $DIFF -gt 60 ]; then
	echo "WARNING: $JSON_FILE seems old, are you sure we're using the right path?"
fi

# Set this to a number
NEXT_JSON_READ=1

# How long to wait before uploads, minimum (in seconds)
WAIT_TIME=5

# How long curl will wait to send data (10 sec default)
MAX_CURL_TIME=10

# How much time (sec) has to pass since last JSON update before we say something
# Initial value is "AGE_COMPLAIN", and then it complains every "AGE_INTERVAL" after that
# Deftauls are:
#  AGE_COMPLAIN = 30 sec
#  AGE_INTERVAL = 30 min (1800 sec)
AGE_COMPLAIN=30
AGE_INTERVAL=$(( 30 * 60 ))
OLD_AGE=$AGE_COMPLAIN
while true; do
	while [ $JSON_STAT -lt $NEXT_JSON_READ ]; do

		sleep 1

		NOW=$(date +%s)

		# Grab new stat.  If it fails, wait longer (otherwise assign to the main var)
		NEW_STAT=$(stat --printf="%Y" $JSON_FILE 2> /dev/null)
		RV=$?
		if [ $RV -ne 0 ]; then
			sleep 10
		else
			JSON_STAT=$NEW_STAT
		fi
		DIFF=$(( NOW - JSON_STAT ))
		if [ $DIFF -gt $OLD_AGE ]; then
			echo "WARNING: JSON file $JSON_FILE has not been updated in $DIFF seconds. Did your decoder die?"
			OLD_AGE=$(( OLD_AGE + AGE_INTERVAL ))
		else
			# Reset this here, in case it comes back ;)
			OLD_AGE=$AGE_COMPLAIN
		fi
	done
	# Update this for the next loop
	NEXT_JSON_READ=$(( JSON_STAT + $WAIT_TIME ))

	# Move the JSON somewhere before operating on it...
	RAND=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c10)
	TMPFILE="${TEMP_DIR}/json-${RAND}"
	NEWFILE="${TMPFILE}-new"

	# Sanity to make sure we can write
	T=$(touch $TMPFILE 2>&1)
	RV=$?
	if [ $RV -ne 0 ]; then
		echo "ERROR: Unable to write to $TMPFILE, aborting!  ($T)"
		exit 99
	fi

	CP=$(cp $JSON_FILE $TMPFILE)
	RV=$?
	if [ $RV -ne 0 ]; then
		# cp failed (file changed during copy, usually), wait a few and loop again
		sleep 2
		continue
	fi

	echo '{"uuid":"'$UUID'",' > $NEWFILE
	echo '"aircraft":' >> $NEWFILE
	# -c means "compact" form (not pretty-printed) -- saves space!
	jq -c '.aircraft' $TMPFILE >> $NEWFILE
	echo '}' >> $NEWFILE
  
	# Push up the data.  'curl' will wait no more than $MAX_CURL_TIME seconds for upload to complete
	CURL=$(cat $NEWFILE | gzip | curl -m $MAX_CURL_TIME -sS -X POST -H "Content_Encoding: gzip" --data-binary @- $REMOTE_URL 2>&1 )
	RV=$?

	if [ $RV -ne 0 ]; then
		echo "WARNING: curl process returned non-zero ($RV): [$CURL]"
		echo "Sleeping a little extra."
		sleep $(( 5 + RANDOM % 15 ))
	fi

	rm -f $TMPFILE $NEWFILE > /dev/null 2&>1

done

